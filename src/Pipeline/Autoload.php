<?php
/**
 * Generate an `autoload.php` file in the root of the target directory.
 *
 * @see \Composer\Autoload\ClassMapGenerator
 */

namespace BrianHenryIE\Strauss\Pipeline;

use BrianHenryIE\Strauss\Composer\Extra\StraussConfig;
use BrianHenryIE\Strauss\Helpers\FileSystem;
use Composer\ClassMapGenerator\ClassMapGenerator;
use League\Flysystem\StorageAttributes;
use League\Flysystem\WhitespacePathNormalizer;
use Psr\Log\LoggerAwareTrait;
use Psr\Log\LoggerInterface;
use Psr\Log\NullLogger;

class Autoload
{
    use LoggerAwareTrait;

    protected FileSystem $filesystem;

    protected string $workingDir;

    protected StraussConfig $config;

    /**
     * The files autoloaders of packages that have been copied by Strauss.
     * Keyed by package path.
     *
     * @var array<string, array<string>> $discoveredFilesAutoloaders Array of packagePath => array of relativeFilePaths.
     */
    protected array $discoveredFilesAutoloaders;

    protected string $absoluteTargetDirectory;

    /**
     * Autoload constructor.
     *
     * @param StraussConfig $config
     * @param string $workingDir
     * @param array<string, array<string>> $discoveredFilesAutoloaders
     */
    public function __construct(
        StraussConfig $config,
        string $workingDir,
        array $discoveredFilesAutoloaders,
        Filesystem $filesystem,
        ?LoggerInterface $logger = null
    ) {
        $this->config = $config;
        $this->workingDir = $workingDir;
        $this->discoveredFilesAutoloaders = $discoveredFilesAutoloaders;

        $this->filesystem = $filesystem;
        $this->setLogger($logger ?? new NullLogger());


        $targetDirectory = ltrim(sprintf(
            '%s/%s/',
            trim($this->workingDir, '/\\'),
            trim($this->config->getTargetDirectory(), '/\\')
        ), '/\\');

        $pathNormalizer = new WhitespacePathNormalizer();
        $targetDirectory = $pathNormalizer->normalizePath($targetDirectory) . '/';

        $targetDir = $this->config->isDryRun()
            ? 'mem://' . ltrim($targetDirectory, '/')
            : $targetDirectory;

        $this->absoluteTargetDirectory = $targetDir;

        $this->logger->debug('Using target directory: ' . $this->absoluteTargetDirectory);
    }

    public function generate(): void
    {
        // Use native Composer's `autoload.php` etc. when the target directory is the vendor directory.
        if ($this->config->getTargetDirectory() === $this->config->getVendorDirectory()) {
            $this->logger->debug('Not generating autoload.php because the target directory is the vendor directory.');
            return;
        }

        if (! $this->config->isClassmapOutput()) {
            $this->logger->debug('Not generating autoload.php because classmap output is disabled.');
            return;
        }

        $this->generateClassmap();

        $this->generateFilesAutoloader();

        $this->generateAutoloadPhp();
    }

    /**
     * Uses Composer's `ClassMapGenerator::createMap()` to scan the directories for classes and generate the map.
     *
     * createMap() returns the full local path, so we then replace the root of the path with a variable.
     *
     * @see ClassMapGenerator::dump()
     *
     */
    protected function generateClassmap(): void
    {
        // Hyphen used to match WordPress Coding Standards.
        $output_filename = "autoload-classmap.php";

        // TODO: This should be created from the discoveredFiles list?
        $paths =
            array_map(
                function ($file) {
                    return $this->config->isDryRun()
                        ? new \SplFileInfo('mem://'.$file->path())
                        : new \SplFileInfo('/'.$file->path());
                },
                array_filter(
                    $this->filesystem->listContents($this->absoluteTargetDirectory, true)->toArray(),
                    fn(StorageAttributes $file) => $file->isFile() && in_array(substr($file->path(), -3), ['php', 'inc', '.hh'])
                )
            );

        $dirMap = ClassMapGenerator::createMap($paths);

        $this->logger->info('Composer\\ClassMapGenerator\\ClassMapGenerator::createMap() found ' . count($dirMap) . ' classes.');

        array_walk(
            $dirMap,
            function (&$filepath, $_class) {
                $filepath = sprintf(
                    "\$strauss_src . '/%s'",
                    ltrim(str_replace($this->absoluteTargetDirectory, '', $filepath), '/')
                );
            }
        );

        ob_start();

        echo "<?php\n\n";
        echo "// {$output_filename} @generated by Strauss\n\n";
        echo "\$strauss_src = dirname(__FILE__);\n\n";
        echo "return array(\n";
        foreach ($dirMap as $class => $file) {
            // Always use `/` in paths.
            $file = str_replace(DIRECTORY_SEPARATOR, '/', $file);
            echo "\t'{$class}' => {$file},\n";
        }
        echo ");";

        $this->logger->info('Writing classmap to ' . basename($this->absoluteTargetDirectory) . '/' . $output_filename);
        $this->filesystem->write(
            $this->absoluteTargetDirectory . $output_filename,
            ob_get_clean()
        );
    }

    protected function generateFilesAutoloader(): void
    {
        if (empty($this->discoveredFilesAutoloaders)) {
            $this->logger->info('Skipping generating autoload-files.php because no packages contained files autoloaders.');
            return;
        }

        // Hyphen used to match WordPress Coding Standards.
        $outputFilename = "autoload-files.php";

        ob_start();

        echo "<?php\n\n";
        echo "// {$outputFilename} @generated by Strauss\n";
        echo "// @see https://github.com/BrianHenryIE/strauss/\n\n";

        foreach ($this->discoveredFilesAutoloaders as $packagePath => $files) {
            foreach ($files as $file) {
                $targetRelativeFilepath = "/{$packagePath}/{$file}";
                $filePathinfo = pathinfo($this->absoluteTargetDirectory . $targetRelativeFilepath);
                if (!isset($filePathinfo['extension']) || 'php' !== $filePathinfo['extension']) {
                    continue;
                }
                // Always use `/` in paths.
                $targetRelativeFilepath = str_replace(DIRECTORY_SEPARATOR, '/', $targetRelativeFilepath);
                echo "require_once __DIR__ . '{$targetRelativeFilepath}';\n";
            }
        }

        $this->logger->info('Writing files autoloader to ' . basename($this->absoluteTargetDirectory) . '/' . $outputFilename);
        $this->filesystem->write(
            $this->absoluteTargetDirectory . $outputFilename,
            ob_get_clean()
        );
    }

    /**
     * TODO: check does `autoload-files.php` exist before including it in the output. `autoload-classmap.php` will
     * always exist (or this tool has done nothing).
     */
    protected function generateAutoloadPhp(): void
    {

        $autoloadPhp = <<<'EOD'
<?php
// autoload.php @generated by Strauss

if ( file_exists( __DIR__ . '/autoload-classmap.php' ) ) {
    $class_map = include __DIR__ . '/autoload-classmap.php';
    if ( is_array( $class_map ) ) {
        spl_autoload_register(
            function ( $classname ) use ( $class_map ) {
                if ( isset( $class_map[ $classname ] ) && file_exists( $class_map[ $classname ] ) ) {
                    require_once $class_map[ $classname ];
                }
            }
        );
    }
    unset( $class_map, $strauss_src );
}

if ( file_exists( __DIR__ . '/autoload-files.php' ) ) {
    require_once __DIR__ . '/autoload-files.php';
}
EOD;

        $filename = 'autoload.php';
        $absoluteFilepath = $this->absoluteTargetDirectory . $filename;

        $this->logger->info("Writing autoload.php to $filename");
        $this->filesystem->write(
            $absoluteFilepath,
            $autoloadPhp
        );
    }
}
